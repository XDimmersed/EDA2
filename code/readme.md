
# 题目重述（逐问明确）

## 第一问：单起点，单 Layer，无 Gate

* **输入**：`layout.txt` 中多层版图，但本问只关注**起点所在层**；`rule.txt` 仅给出 `StartPos`（起点层名 + 坐标），Via 与 Gate 可忽略。
* **连通定义**：同一层中，**面积重叠、边重合、边界点接触**都视为连通（曼哈顿几何）。
* **任务**：找到起点所在多边形，从它出发，在**同层**内按上述连通定义扩展，输出所有**与之连通**的多边形坐标（逆时针）、分层分组输出（本问只有该层）。

## 第二问：单起点，多 Layer，有 Via，无 Gate

* **输入**：`StartPos` + **Via 规则**。每条 Via 规则是一个层链，如 `L1 L2 L3`，只允许**相邻层**互连（`L1↔L2`、`L2↔L3`），**不允许**跨越直连（`L1↔L3` 不成立，需经 `L2` 传递）。
* **连通定义**：同第一问；**跨层**连通需满足：两个多边形分别处于 Via 允许的相邻层，且几何上“面积重叠/边重合/点接触”。
* **任务**：从起点多边形出发，**在允许的层对之间**递归扩展，输出所有连通多边形（分层分组）。

## 第三问：双起点，多 Layer，有 Via + Gate

* **输入**：两个起点 `s1` / `s2`（层名 + 坐标），Via 规则，**Gate 规则**（`Gate` 行给出 `Poly 层` 和 `AA 层`）。
* **Gate 语义**：

  * 先从 `s1` 出发跑连通（遵守 Via 与几何连通）。凡是**与 s1 连通**的 **Poly 层多边形**，一律视为**高电平**；其它 Poly 视为低电平。
  * **AA 层**中被某条 Poly 贯穿的多边形要**切成左右两片**（源/漏侧）。如果对应的 Poly 为**高电平**，则这两片视为“电气连通”（在搜索时可互达）；若 Poly 低电平，则两片**断开**。
* **任务**：进行“`s1` 激活 → `s2` 搜索”的两阶段：

  1. **阶段 1（s1）**：从 `s1` 起，按第二问的规则搜索，标记所有被访问到的 **Poly** 为 `high`。
  2. **阶段 2（s2）**：从 `s2` 起搜索；遇到 **AA** 多边形时，若它被任一 `high` 的 Poly **完全贯穿**，则**即时切割**该 AA 面为两片，并把这两片视为可互通（把“导通边”加上）；否则维持断开。最终输出 `s2` 可达的所有多边形（AA 被切割的，输出切后的片段）。

> 备注：题面假设 **Poly 对 AA 为“完全贯穿”**（横或竖向把 AA 划为两侧）。我们按这个假设实现切割；为鲁棒，也应检查“贯穿矩形接触 AA 的两侧边界”再判定为可切。

---

# 总体策略（FDEC：Frontier-Driven External Connectivity）

关键思想：**不全量建图**！用**frontier 按需**生成邻接；把最贵的**多边形相交**只花在“当前队首 `u` 的邻域”；**第三问**对 AA 的切割采用**Lazy-Cut**（只在 s2 BFS 真遇到该 AA 且对应 Poly 已 high 时才切一次并缓存）。

---

# 可实现的编程细节（逐模块）

## 1) 解析与 ID 体系

* 读 `rule.txt`：

  * `StartPos`：1 或 2 个起点（层名 + 坐标）。
  * `Via`：多条层链，稍后转为**相邻层邻接表**（只加相邻点对）。
  * `Gate`（可选）：给出 `poly_layer` 与 `aa_layer` 名。
* 读 `layout.txt`：逐层读取多边形顶点（整型，曼哈顿，逆时针；若非逆时针则反转）。

  * 为每个多边形计算 `bbox={minx,miny,maxx,maxy}`。
  * 把边分成**水平边数组 H**、**垂直边数组 V**。
  * 分配**稠密 ID**：`lid`（层），`pid`（层内序号），全局 `gid=((u64)lid<<32)|pid`。
  * 建立 `name2lid`（层名→lid）。

## 2) 几何判定（全用整数）

* **bbox 重叠**（含边界）：快速粗筛。
* **轴对齐线段相交**：

  * `H(A)×V(B)`、`H(B)×V(A)`，**端点接触**与**重合**均算相交。
* **完全覆盖兜底**：若边不交，取 `A.v[0]` 做一次**点包含**于 B（射线法；**点在边上算 inside**）。
* **Point-In-Polygon**：射线法（+x 方向），先测“点在边上”。

> 这些规则统一适用于：同层相交、跨层相交、AA-Poly 穿透判断、起点定位。

## 3) 空间索引：每层一个 Uniform Grid（热点可挂 R-tree）

* `cell_size` 选该层多边形 bbox 宽/高中位数的近似值（限制在 `[16, 4096]` 之间）。
* 每个格子存**覆盖该格的多边形 pid 列表**（桶）。
* 查询时，用 `u.bb` 覆盖的格子**合并桶**得到候选 pid（**局部去重**：排序 unique 或小 bitset/时间戳）。
* 若某些格**极度拥塞**导致候选爆炸，可为该层热点区域额外挂一个**R-tree**，当桶大小超阈值时走 R-tree。

## 4) Via 邻接：由层链转“相邻层表”

* 对每条链 `L1 L2 L3`，只加 `(L1,L2)`、`(L2,L3)`；不要加 `(L1,L3)`。
* 存到 `adj_layers[lid] = {邻接 lid…}`；第二/三问扩展时只在这些层对之间查候选。

## 5) 第一问实现：单层按需 BFS

1. **定位起点多边形**：在起点层 `Ls` 的多边形上，用 `bbox` 粗筛 + `point_in_poly` 精判（边界算 inside）。
2. **BFS**（**同层**）：

   * 出队 `u` → `grid[Ls].query(u.bb)` 得到候选 `v`；
   * 对每个 `v` 做 `bbox_overlap` + `poly_intersect_manhattan(u,v)`，命中即 `visited[v]=true; q.push(v)`。
   * **同层**也要把“边界/角点接触”视为连通。
3. **输出**：只输出 `Ls` 中 `visited`==true 的多边形，逆时针打印。

> 复杂度接近“**可达子图规模**”：候选只来自 `u` 的邻域，而不是全层。

## 6) 第二问实现：跨层按需 BFS（无 Gate）

* 初始定位起点：与第一问相同。
* **BFS 扩展**：对队首 `u(lid, pid)`：

  * **同层**连通（若题面需要）：如上；
  * **跨层**：仅对 `adj_layers[lid]` 中的每个 `nlid`：

    * `grid[nlid].query(u.bb)` → 候选 `npid`；
    * `bbox_overlap + poly_intersect_manhattan` 精判；
    * 命中即入队。
* **输出**：按层分组输出所有 `visited` 节点（多层全打印）。

> 仍是**frontier 按需**，不全量构建跨层边。

## 7) 第三问实现：两阶段 + Gate（Lazy-Cut）

### 7.1 阶段 1（s1 → 激活 Poly）

* 从 `s1` 起，用“第二问”的 BFS 规则在全图（受 Via 限制）扩展。
* **凡访问到 `poly_layer` 的多边形**，`poly_high[poly_pid]=true`。
* 结束后得到一张**Poly 高电平位图**。

### 7.2 阶段 2（s2 → BFS + Lazy-Cut）

* 从 `s2` 起跑 BFS（规则同第二问 + Gate 逻辑）：

  * 当队首 `u` 在 **AA 层**：判断它是否被任意 `high` 的 Poly **完全贯穿**；若是，则**把该 AA 面即时切割成两片**，并把两片视为**互相连通**（把“导通边”激活）。
  * 实现要点：

    1. **粗筛候选**：预先构建 `poly_to_aa_cands`（用 bbox + grid，只存 poly_pid → [可能被其贯穿的 aa_pid…]）。
    2. **精判贯穿**：对 `aa_pid` 的“候选 poly”里，挑那些 `poly_high==true` 的做精判：

       * 计算 `R = AA ∩ Poly` 的**相交矩形/条带**（曼哈顿下是轴对齐矩形）。
       * **贯穿判据**：`R` 同时接触 AA 的**两条相对边界**（横向贯穿接触上下边，纵向贯穿接触左右边）。
    3. **Lazy-Cut**（只切一次并缓存）：

       * 取 `R` 的**中线**作为切割线：

         * 若横向贯穿：切线 `y = (R.miny + R.maxy)/2`；
         * 若纵向贯穿：切线 `x = (R.minx + R.maxx)/2`。
       * 用**扫描线分割** AA：沿切线方向遍历 AA 顶点环，计算与切线的交点（两个），把原环拆成两段并分别闭合为**两个子环**；
       * **保证逆时针**、无自交；
       * 在内存里给两片分配**临时 pid/gid**，记入 `aa_slices[aa_pid]`，并把“两片互联”的条件边**即时激活**（即：若其中一片已访问，另一片可入队）。
  * 若 `aa_pid` 没有被 `high` Poly 贯穿，维持不切割、两侧断开。
* **输出**：本问中，AA 被切割过的，输出**切后的片段**坐标（不是原 AA 面）；其它层照常输出原多边形。

> **为何用中线切？** 曼哈顿完全贯穿时，贯穿条带上下（或左右）两界与 AA 边界贴合，中线保证把 AA 一分为二且不与原边重合，生成两片 CCW 子环最稳妥。

---

# 关键实现细节（必须到位）

### A. 起点定位（两问通用）

* 先 `bbox` 粗筛，再 `point_in_poly`；**点在边上**判 inside（题面把边界接触算连通）。
* 若一层多个多边形都包含该点（罕见），任选其一即可（通常不会发生）。

### B. 曼哈顿相交（同层/跨层/穿透统一口径）

* `bbox_overlap` 是必要条件；
* H×V / V×H 判交，**端点接触/重合**算相交；
* 兜底“完全覆盖”用点包含；
* 全程**整数运算**，避免浮点误差。

### C. 索引与候选去重

* `Uniform Grid`：插入时把多边形 bbox 覆盖的格子全挂上；查询时合并 `u.bb` 的覆盖格桶；
* 每次查询候选要**局部去重**（排序 unique / 小 bitset / 时间戳数组）；
* **热点格**触发 R-tree 或细分格，以免候选爆炸。

### D. BFS 访问标记

* 先用 `unordered_set<u64>` 做 `visited`（便于上手）；走性能时换成**位图/压缩位图（Roaring）**。
* 两起点（第三问）可按两阶段分开跑，避免来源冲突。

### E. Lazy-Cut 缓存

* 一个 `aa_pid` 只切一次：`aa_slices[aa_pid].ready=true` 后，后续直接复用两片的 gid。
* 为输出方便，两个子片需要保存**顶点序列**（逆时针）。

---

# 输出与格式一致性

* 按 **Layer** 分组输出：先输出层名行，再逐行输出多边形坐标（`(x,y)` 空格分隔），**逆时针**。
* 第三问：AA 被切割的，**只输出切片**，不要再输出原 AA 面。
* 边界/角点接触在整个流程中口径一致（相交/inside）。

---

# 并行与调优（通过 `-thread n` 控制）

1. **候选生成 + 精判并行**（优先）：

   * 把当前 frontier 切片给多个线程：每个线程做 grid 查询、候选去重、几何精判，产出“新 gid 列表”；
   * 主线程批量合并，统一置位 `visited`、统一入队（或分片位图减少原子冲突）。
2. **索引构建并行**：按层建格子桶并行。
3. **遍历并行**：可做“层次 BFS”的批次并行，但收益通常不如候选并行可控。
4. **I/O 与缓存**：数据量很大时，把 `layout.txt` 解析结果落成**二进制缓存 + mmap 顺序读**（先不做也能通过正确性；性能阶段再上）。

---

# 正确性自检清单

* ✅ **角点接触**是否被判为相交？
* ✅ **边界重合**是否被判为相交？
* ✅ **同层**是否按题面要求考虑连通（第一问必须；第二问常见也要）？
* ✅ **Via 只连相邻层**，不跨越直连？
* ✅ **起点在边上**是否能定位到多边形？
* ✅ **第三问**中： `s1` 激活 Poly → `s2` 才做 Lazy-Cut；未激活的 Poly 不导通 AA；被切割的 AA 是否只输出切片？
* ✅ **输出逆时针**、格式严格、分层分组无误？


-
